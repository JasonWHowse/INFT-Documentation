CSC 478: Software Engineering Capstone

Group Project Assignment

300 points

Team Guidelines

As a software engineering team, you are responsible for building a functional software application replete with thorough documentation of all of your process activities. In order to successfully accomplish this goal, you will have to work together as a team - everyone must share the workload. No individual team member should have to shoulder the majority of the burden. There are several obstacles you will need to overcome:
1. As individuals, you likely don’t know each other very well and have never worked together before, so you will have to quickly become acquainted.
2. As individuals, you are separated geographically, so you will not be able to have face-to-face meetings.
3. The time constraint is severe (you only have about 11-12 weeks) and immutable (since I have to submit final grades at the end of the semester).
4. You probably have other classes and/or a paying job and/or a family, all of which will limit the amount of time you can devote to the project.
5. You are not being paid for building the software, so money is not a motivator for doing well on the project.
I will not dictate to you how you should overcome these obstacles, but I will offer a few guidelines which you are free to adopt as you see fit.
Getting Acquainted
You should probably spend some time initially learning about each other. The group discussion board is good for this, but email or even phone calls will work as well. Here are some suggestions for things to talk about:
1. Get to know each other’s strengths and weaknesses. Who is likely to be best suited for coding? Who has experience with techincal writing? Does anyone on the team develop software professionally?
2. Find out when each person is available for participating in group discussions, online chats, email conversations, etc.
3. Find out how much time each person will be able to devote to the project.
4. Will there be any times when someone will be unavailable (e.g., business trip, Thanksgiving holiday, etc.)?
Communication
Communication is always a problem where group projects are involved. Since most of you will only be communicating with each other online, via email, discussion forums, etc., communication
may or may not be more problematic than normal, depending on how much you depend on face-to-face meetings. I can assure you that in the industry, it is not uncommon for people who are distributed geographically to work on the same project, so what we are doing is not really that far-fetched an idea. For this course, the Blackboard site provides group discussion forums, and allows group emails, group file transfers, and even group online chat capabilities (if you need more synchronicity to your communication). Feel free to set up any other mechanisms for communicating, transferring files, etc. as you see fit.
Deciding on a Team Name
Having a team name often promotes team spirit and motivation. One of your first tasks as a team should be to decide upon a team name. Initially all teams will be given generic names such as Team #1, Team #2, etc. You may keep the generic name, if you wish.
Choosing a Team Structure
Once you’ve become acquainted, you will need to decide on a team structure. I’ve discussed the three major categories of team structure in the lecture. You are free to choose whichever structure you wish, but given the time constraints and the geographic separation of your team members, I recommend the democratic centralized structure. Since this is supposed to be an educational endeavor, everyone must be allowed to participate significantly. But, it is wise to give someone executive power to make final decisions to keep the project moving forward.
The decision of which team structure to use should be made democratically, to minimize the chances of creating dissension within the team.
Dividing the Workload
After coming up with your team structure, you must figure out how to divide the workload among the various team members. You may do this however you see fit, but you might consider using the following roles when dividing the workload (this is not mandatory, only a suggestion):
1. Documentation Specialist — responsible for writing the user’s manual, documenting umbrella activities such as the project plan, and compiling all documentation in a presentable format. Coders will still document their own code, and designers will still document their own designs.
2. Architect — responsible for designing the software, based on the requirements.
3. Coder — responsible for implementing all designs.
4. Tester — responsible for the test plan, and conducting all tests.
A single individual can be assigned to each role, or the roles can be shared. This has important implications, because it means that you can assign someone to do nothing but documentation, someone else to do nothing but testing, etc. So yes, it is possible for you to get an A in this course without writing a lick of code. The goal of this course is not for each individual to design, implement, and test a piece of software, but to work together effectively as a team to design, implement, and test a piece of software.
Although you have a great deal of latitude in dividing the labor, I am imposing some constraints:
1. Everyone on the team must contribute equally (as much as possible) on the project. Having a team member whose sole responsibilities are to write the scope statement, or construct the Gantt chart as their sole contribution, for example, is not acceptable.
2. You are responsible for doing whatever is necessary to work together as a group. I say this because in the past some students have complained about the roles they were assigned by their teams. They wanted to be more involved in the coding or design aspect, or they were unhappy because they got stuck doing mostly documentation. For this project you may find you will need to set aside your personal goals for the good of the group.
3. If someone on the team does not pull their weight, the burden is on the other team members to do what they can to rectify the situation, and failing that, inform me of the situation. This is important! When I grade I will be grading the projects, not the individuals, unless there is compelling evidence to do otherwise. Whatever grade I assign to the project will be the grade each team member receives. So, for example, if I give your project a grade of 275 points out of 300, each team member will receive 275 points for the project.
4. In the event it becomes apparent that a particular individual just isn’t going to work out for a given team, for any reason, either the individual or the team needs to inform me ASAP. Early in the project I may be able to move people around, but there are no guarantees.
Project Ideas
Experience has shown that students tend to be more motivated to work on projects they have chosen themselves than they are on projects that are assigned. Since motivation is such a key factor to success, I give you the option of choosing your own project. There are some constraints, of course:
1. You may NOT reuse a project you have built for some other class or employer. You MAY, however, take an existing project and extend it, although for this to count you must add a significant amount of functionality.
2. You must write at least 50% of the code for the project. So, stitching together pre-built components with a small amount of “glue code” is not acceptable for this course (even though it may be a viable option in the real world).
3. The functionality must not be trivial. An extreme example of trivial functionality would be the canonical, “Hello, World” program. On the other hand, you must take care not to overdo it, or you won’t have time to finish everything.
4. Your software must be designed to work on a system running Windows 10, as that is the only OS I have available at the moment.
5. If you decide to build a web-based application, or an application that requires a network connection, you will be entirely responsible for ensuring the web server and other network services are operational on your end. If I am unable to test your application because of network problems, permission problems, etc., you will lose points.
6. If you know your project will have dependencies on third-party libraries, frameworks, etc., you must be able to have your installation package install those dependencies. If I am unable to test your application due to missing dependencies, or configuration issues, you will lose points. To help prevent these types of problems, make sure you test your software on a non-production computer.
7. I must give final approval of your project before you begin working on it. If you choose a project that has been built before by other people (many people have built common games like Yahtzee and poker, for example) I may require that you introduce a twist or two to make your project unique.
Examples of some past projects students have chosen include:
1. board games: Clue, Sorry, Monopoly, Battleship
2. card games: UNO, poker
3. dice games: Yahtzee
4. casino games: roulette
5. MP3 catalog and player system
6. a first person shooter game in which players drive tanks in a 3-D environment and shoot at each other
7. a fantasy role-playing game that utilizes 3-D graphics, where the player controls a character that can cast spells, fight, etc.
If you find you cannot decide on a project, let me know and I will come up with one for you.
Software Process
Several different processes, or workflows, that can be used for engineering software are covered in this course. Each process has its pros and cons. For your group project I strongly encourage you to adopt an iterative or incremental process. Given the time constraints and your limited human resources, most of the other models we’ve discussed won’t work for you. Once you have determined and documented your requirements, I suggest dividing the proposed functionality into multiple versions. Version 1 should contain the features with the highest priority. Subsequent versions should extend previous versions by adding new features or refining existing features. The advantage of this process is that you will be more sure of having something to submit that works, even if it doesn’t do everything you would like or it doesn’t work as efficiently as you would like.
For example, let’s say you’re building the poker game used an example on the page discussing the project deliverables, and you divide your requirements into 8 major pieces of functionality. You decide to adopt an incremental approach to building the system, with four development versions:
1. dev. version 1.0.0
• cards can be generated based on information in a data file
• cards can be displayed in bare bones GUI window
2. dev. version 2.0.0
• basic GUI developed
• implement 5-card stud variant
3. dev. version 3.0.0 -
• adds save game and load game features
• implement 7-card stud variant
4. dev. version 4.0.0
• implement Texas Hold’em variant
• context-sensitive help feature added
Now, suppose that by the time you’ve completed development version 3.0.0 and tested it, you only have one more week before the project deadline. You begin implementing the Texas Hold’em variant, but run into problems getting it to work correctly, and you didn’t have time to fully implement the context-sensitive help feature. So, you haven’t fulfilled all your requirements, BUT you have a functional version 3.0.0 that you can submit.
Project Deliverables (see calendar for due date)
There will be 4 deliverables you will need to submit for your project, which are listed below, and will be explained in greater detail in the following pages:
1. The Project Plan — contains all the documentation for the umbrella activities
2. The Programmer’s Manual — contains everything a software engineer needs if he or she were to maintain the software
3. The User Documentation — all documentation an end user would need to install and use the software
4. The Final Product — this is the executable software, along with all data files, library files, drivers, and any other file necessary for the software to be used
You will see that a large portion of your grade for the project is determined by your documentation. Documentation is essential to building quality software (although Agile Developers may disagree, for this course documentation is mandatory). Since all software is built to solve some problem, the process documentation serves to encapsulate a solution to that problem, as well as how that solution was arrived at and why that particular solution was used. The finished executable may seem to work flawlessly, but lack of sufficient documentation can be disastrous later on when the software needs to be maintained or changed. There is no guarantee the software will be maintained by the same development team that built it originally, and even if the original team is involved, people tend to forget things over time. Even if the software is never maintained, the documentation can be invaluable should it become necessary to build software to solve similar problems in the future.
As a rule, you should document your project under the assumption that a completely different team, which knows nothing about the problem you are solving, will need to make significant changes to the software, and this team will not have the option of contacting any of you for assistance.
One final note: Professionalism is important! Don’t haphazardly slap your documentation together. Be consistent with formatting, use of fonts, etc. Make sure your documentation is well organized, and understandable, so that it’s clear what I’m looking at. The guidelines on this page, along with the project rubric, should keep you on the right track. If you are unsure about anything, please e-mail ASAP!
All deliverables must be submitted no later than the due date listed on the course calendar.